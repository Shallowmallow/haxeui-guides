Events
================================


An event is a signal that the system fires to tell something has occured. Code can be written to listen to this signal and act on it.

There are many types of events, here are a few examples:
- it can be mouse event, the user has clicked a component
- it can be a UI event, a component has been shown
- it can be keyboard event, something has been typed
- and many others

Haxe-ui provides multiple easy ways to listen to these events.

## Listening to events


### The XML way

Using xml, it is easy to listen to events. For example:

```xml
<vbox style="padding: 5px;">
<box width="400" height="500" backgroundColor="red" onClick="trace('you clicked on red');"/>
</vbox>
```

will trace something if you click on the red box.


Let's look at the actual  code produced by haxeui

```haxe
c0.registerEvent("click", function(event:haxe.ui.events.UIEvent) {
    var __this__ = c0;
    {
        `trace("you clicked on red", {fileName : "src/MainView.hx", lineNumber : 6, className : "MainView", methodName : "new"});
    };
});
```

What does it teach us  ?

First thing, to listen to an event, you just have to know the event name, and do `on`+ the name of the event type.
`onclick`, `onClick`, `onCLICK` all work.

This work for any events `onShown`, `onReady`, etc also work

Second thing, is that you have also access to the event instance, by using the `event` variable.

```xml
<vbox style="padding: 5px;">
<box width="400" height="500" backgroundColor="red" onClick="trace(event);"/>
</vbox>
```


### In Code

#### Using the macro "@:bind"

You can use the macro bind, which is quite convenient

`@:bind(component, event)`

```haxe
@:bind(button, MouseEvent.CLICK)
function onClickButton(_) {
    trace("you've just clicked on the button");
}
```

let's look at the produced haxe code

```haxe
public function new() {
    var _gthis = this;
    super();
    [...]
    var c = this.button;
    if ((c != null)) c.registerEvent(haxe.ui.events.MouseEvent.CLICK, this.onClickButton) else `trace("WARNING: could not find component to register event (" + "this" + ")", {fileName : "src/MainView.hx", lineNumber : 12, className : "MainView", methodName : "new"});

```

You can use multiple binds before a function
```haxe
@:bind(button, MouseEvent.CLICK)
@:bind(button1, MouseEvent.CLICK)
function onClickButton(_) {
    trace("you've just clicked on some button");
}
```


You can actually bind an event to whatever component you can access in the class which exist at the creation of the component so `this` or `button`.
You cannot access `parentComponent` for example, because the parentComponent is set when the component is added to its parent, which is after the creation  of the component.

```haxe
@:bind(this, MouseEvent.CLICK)
function onClickButton(_) {
    trace("you've just clicked me");
}
```

This brings on to the registerEvent method

#### Using the register event method

To register events to a component you can use directly the haxe function `registerEvent`.

Here is the definition

```haxe
registerEvent<T:UIEvent>(type:EventType<T>, listener:T->Void, priority:Int = 0)
```

Using directly the function enables us to set the priority parameter which is useful when registering multiple time the same events

```haxe
registerEvent(haxe.ui.events.MouseEvent.CLICK, function(e){ trace("written second"); }, 88);
registerEvent(haxe.ui.events.MouseEvent.CLICK, function(e){ trace("written first"); }, 888);
```

Or to make an event happen before the default haxeui behaviour.

The bigger the number, the higher the priority.


Using the function makes it more natural to also unregisterEvents.

```haxe
registerEvent(haxe.ui.events.MouseEvent.CLICK, doStuff, 888);
unregisterEvent(haxe.ui.events.MouseEvent.CLICK, doStuff);
```

You don't need to unregister events. *Events that are attached to components are automatically unregistered when the components are destroyed.*

But if you only use once the type of event, and want to register and unregister multiple times a function, better to use a convenience variable.

#### Using the convenience variables

Components have convenience pvariables for most used events.

`onChange`

`onClick`
`onMouseOver`
`onMouseOut`
`onDblClick`
`onRightClick`

`onDragStart`
`onDrag`
`onDragEnd`
`onAnimationStart`
`onAnimationFrame`
`onAnimationEnd`

The make it easy to change functions to trigger without having to unregister the event

```haxe
onClick = function(e) {
    // do stuff;
    onClick = function(e) {
        // do different stuff now
    }
}

```

#### Overriding functions


There is also another way to change default events of a component.
Simply by overriding the registered called functions.

For example,

```haxe
public override function onReady() {
        super.onReady();
        // do stuff
}
```

You can also the same for  `onInitialize()`, `onResized()` and others depending on the component

```

## Type of events

There are many events that are generated by haxeui. Let's look at some of some them


### UI Events

UI events are usually attached to a component

#### CHANGE

A `change` event is dispatched when the value of the component has changed.

#### READY

A `ready` event is dispatched when the value when size is calculated

#### RESIZE

A `resize` event is dispatched when the value of the component has been resized.

#### DESTROY
#### INITIALIZE
#### MOVE
#### HIDDEN
#### SHOWN
#### ENABLED
#### DISABLED
#### COMPONENT_ADDED
#### COMPONENT_REMOVED
#### COMPONENT_ADDED_TO_PARENT
#### COMPONENT_REMOVED_FROM_PARENT


#### Others are specific to certain components

- BEFORE_CHANGE
- SUBMIT_START
- SUBMIT
- RENDERER_CREATED
- RENDERER_DESTROYED
- BEFORE_CLOSE
- CLOSE
- PROPERTY_CHANGE


### Mouse Events




### Keyboard Events

You don't attach keyboard events to a component but to a screen instance.
That's why you musn't forget to unregister it

```haxe
function shortcut (e) {
// function
}
Screen.instance.registerEvent(KeyboardEvent.PRESS, shortcut)

registerEvent(UIEvent.DESTROY, function f(e) {
    Screen.instance.unregisterEvent(KeyboardEvent.PRESS, shortcut)
});
```


### Action Events

Action events are a way to separate the intention of the event from the source of it.

It works a little differently than other events.
There are only two types
```haxe
ACTION_START // when the action starts
ACTION_END   // when the action stops
```

For most actions, you only need to use `ACTION_START`.
`ACTION_END` is mostly used by button release or keys up.



Then you have to switch on the type of action to know which it was
```haxe
@:bind(this, ActionEvent.ACTION_START)
private function onActionStart(event:ActionEvent) {
    switch (event.action) {
        case ActionType.DOWN:
            goDown();
        case ActionType.UP:
            goUp();
        case ActionType.LEFT:    
            goLeft();
        case ActionType.RIGHT:    
            goRight();
        case _:      
    }
}
```


For example, there are multiple action types
```haxe
    var PRESS = "actionPress";
    var LEFT = "actionLeft";
    var RIGHT = "actionRight";
    var UP = "actionUp";
    var DOWN = "actionDown";
    var NEXT = "actionNext";
    var PREVIOUS = "actionPrevious";
    var BACK = "actionBack";
    var OK = "actionOK";
    var CONFIRM = "actionConfirm";
    var CANCEL = "actionCancel";
```


These actions can be produced by multiple sources a keyboard, a keypad, a mouse, the buttons of a smartphone, a touchscreen etc. But all will send the correct action if they are registered and configured correctly.
By default, only keyboards are configured and registered.

There are multiple advantages of using action events.

- having multiple sources for the same event
- being able to configure the source as you wish. You can imagine, some keyboard players setting the wasd keyboard for example.
- having these events attached to a component instead of the screen for keyboard events, it makes it easier to manage.

### Repeating events

Some actions can be considered repeated if they haven't ended.
For example, if you do an `ActionType.DOWN` when typing the the down arrow. You usually want multiple events to dispatch even if you only pressed the down button once.

The event will continue to dispatch until there's a `ACTION_END` that happens.

In this case you can set up the `event.repeater` to `true`
To control the interval between each dispatching of the event.
You can use the `actionRepeatInterval` variable of the component.

```haxe
actionRepeatInterval = 100; // this is the default, it's in ms
@:bind(this, ActionEvent.ACTION_START)
private function onActionStart(event:ActionEvent) {
    switch (event.action) {
        case ActionType.DOWN:
            goDown();
            // If the user one ActionType.DOWN, by pressing the the key
            // Every 100ms an event will be dispatched until the user release the key.
            event.repeater = true;
        case _:      
    }
}
```

## Pausing and resuming events

You can pause event by using the function pauseEvent(type:String, recursive:Bool = false)

and resumeEvent(type:String, recursive:Bool = false)

## Cancelling events



## Creating your own custom events






